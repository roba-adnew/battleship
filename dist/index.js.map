{"version":3,"file":"index.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,8BAA8B;AAC9B;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA,uDAAuD,iBAAiB;AACxE;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,UAAU;;AAEjC,4BAA4B,iBAAiB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,sBAAsB;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,mBAAmB,UAAU;;AAE7B;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;;AAGO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1P4D;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,oDAAM;AACzB,iBAAiB,oDAAM;;AAEvB;AACA;AACA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C,oDAAoD,EAAE;AACtD,kDAAkD,EAAE;AACpD;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD,mCAAmC,EAAE,GAAG,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;UC5CA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACN8C;;AAE9C,2DAAkB,G","sources":["webpack://battleship/./src/gameObjects.js","webpack://battleship/./src/gameUI.js","webpack://battleship/webpack/bootstrap","webpack://battleship/webpack/runtime/define property getters","webpack://battleship/webpack/runtime/hasOwnProperty shorthand","webpack://battleship/webpack/runtime/make namespace object","webpack://battleship/./src/index.js"],"sourcesContent":["function coordMatches(coord1, coord2) {\n    const xAvail = coord1[0] === coord2[0];\n    const yAvail = coord1[1] === coord2[1];\n    return xAvail && yAvail\n}\n\nfunction Ship(length) {\n    \n    let hits = 0;\n    function hit() { return hits++ };\n    function isSunk() { return hits >= length };\n    let slot = [];\n    \n    return { \n        length,\n        hit, \n        isSunk, \n         get slot() { return slot },\n         set slot(location) { slot = location } }\n}\n\nexport function Gameboard() {\n    const DIM = 8;\n    const shipLengths = [4,3,3,2,2,2,1,1,1,1];\n\n    function createBoard() {\n        let board = Array(DIM)\n            .fill()\n            .map(() => Array(DIM).fill(' '));\n\n        return board;\n    }\n\n    function isOnBoard(coord) {\n        const validX = coord[0] >= 0 && coord[0] < DIM; \n        const validY = coord[1] >= 0 && coord[1] < DIM;\n        return validX && validY;\n    }\n\n    function createShips() {\n        \n        const shipObjects = [];\n        shipLengths.map((length) => {\n            const ship = Ship(length);\n            ship.slot = findSlot(ship, shipObjects);\n            shipObjects.push(ship)\n        })\n        return shipObjects;\n    }\n\n    function findSlot(ship, shipObjects) {\n\n        function locationAvail(coord, shipObjects) {\n            if (shipObjects.length === 0) return true;\n\n            const slots = [...shipObjects.map(ship => {return ship.slot})]\n            if (slots.length === 0) return true;\n\n            const isSlotClear = slots\n                .every((space) => { \n                    if (!space) return true;\n                    else {!coordMatches(coord,space) }\n                });\n\n            return isSlotClear;\n        }\n\n        const layoutDirections = [[0,1],[0,-1],[-1,0],[1,0]]\n        let slot;\n        let isBadSlot = true;\n        \n        do {\n            slot = [];\n            const rand = Math.round(Math.random() * 3);\n            const [xDir, yDir] = layoutDirections[rand];\n\n            let [xStart, yStart] = Array\n                .from({length: 2}, () => Math.round(Math.random() * (DIM - 1)));\n\n            for (let i = 0; i < ship.length; i++) {\n                const xPos = xStart + (i * xDir);\n                const yPos = yStart + (i * yDir);\n                const pos = [xPos, yPos];\n\n                if (!isOnBoard(pos))  break \n                if (!locationAvail(pos, shipObjects)) break \n\n                slot.push(pos);\n            }\n\n            isBadSlot = slot.length !== ship.length;\n        }\n        while (isBadSlot)\n\n        return slot;\n    }\n\n    function receiveAttack(coord) {\n        if (!isOnBoard(coord)) return false;\n        \n        const allHits = [...hitSpaces.openSpaces, ...hitSpaces.shipSpaces];\n        const alreadyHit = allHits.some((hit) => coordMatches(hit, coord));\n        if (alreadyHit) return false;\n\n        for (let ship of shipObjects) {\n            const goodHit = ship.slot\n                .some((space) => coordMatches(coord, space));\n            if (goodHit) {\n                ship.hit();\n                const hit = { 'ship' : coord };\n                updateHitSpaces(hit);\n                return hit;\n            }\n        }\n\n        const hit = { 'open' : coord };\n        updateHitSpaces(hit);\n        return hit;\n        \n    }\n\n    function updateHitSpaces(hit) {\n        const spaceType = Object.keys(hit)[0];\n        const coord = Object.values(hit)[0];\n        if (spaceType === 'ship') {\n            hitSpaces.shipSpaces.push(coord);\n        }\n        else if (spaceType === 'open') {\n            hitSpaces.openSpaces.push(coord);\n        }\n        else {\n            throw new Error('Updating hitspaces went wrong');\n        }\n        updatePrivateBoard();\n        updatePublicBoard();\n    }\n\n    function allShipsSunk() {\n        return shipObjects.every((ship) => { return ship.isSunk() })\n    }\n\n    function updatePrivateBoard() {\n        const privateBoard = createBoard();\n        shipObjects.\n            forEach((ship) => {\n                ship.slot.forEach(([x,y]) => privateBoard[x][y] = 'T');\n            });\n        hitSpaces.shipSpaces.forEach(([x,y]) => privateBoard[x][y] = 'X');\n        hitSpaces.openSpaces.forEach(([x,y]) => privateBoard[x][y] = 'O');\n\n        return privateBoard;\n    }\n    \n    function updatePublicBoard() {\n        const publicBoard = createBoard();\n        hitSpaces.shipSpaces.forEach(([x,y]) => publicBoard[x][y] = 'X');\n        hitSpaces.openSpaces.forEach(([x,y]) => publicBoard[x][y] = 'O');\n\n        return publicBoard;\n    }\n\n    function printPrivateBoard() { \n        const privateBoard = updatePrivateBoard(); \n        console.table(privateBoard) \n    };\n\n    function printPublicBoard() { \n        const publicBoard = updatePublicBoard();\n        console.table(publicBoard) \n    };\n\n    const shipObjects = createShips();\n    const hitSpaces =  { openSpaces: [], shipSpaces: []};\n     \n    return { \n        receiveAttack, \n        updatePrivateBoard,\n        updatePublicBoard,\n        printPrivateBoard, \n        printPublicBoard, \n        get DIM() { return DIM} , \n        hitSpaces, \n        shipObjects, \n        allShipsSunk }\n}\n\nexport function Player(isUser) {\n    function computerHit() {\n        const attemptedHits = [];\n        let hit = Array\n            .from({length: 2}, () => Math.round(Math.random() * (board.DIM - 1)));\n\n        let isHitGood = false;\n\n        do {\n            let alreadyTried = attemptedHits.some((prevHit) => { \n                return coordMatches(prevHit, hit) \n            });\n\n            if (alreadyTried) {\n                hit = Array\n                    .from({length: 2}, \n                        () => Math.round(Math.random() * (board.DIM - 1)));\n            }\n            else {\n                attemptedHits.push(hit)\n                isHitGood = true;\n            }\n        }\n        while(!isHitGood)\n        \n        return hit  \n        }\n\n    function userHit() {\n        const stringCoord = prompt(\"Where do you want to attack?: \");\n        const xPos = parseInt(stringCoord.charAt(0));\n        const yPos = parseInt(stringCoord.charAt(1));\n        return [xPos, yPos]\n    }\n    \n    const attemptHit = isUser ? userHit : computerHit;\n    const board = Gameboard();\n\n    return { board, attemptHit }\n}\n\n\nexport function gameplay(player1, player2) {\n    let winner;\n    let attackingPlayer = player1;\n    let receivingPlayer = player2;\n    do {\n        let hit = attackingPlayer.attemptHit();\n        let attackLanded = receivingPlayer.board.receiveAttack(hit)\n        if (!attackLanded) { continue }\n        \n        receivingPlayer.board.printPrivateBoard();\n        attackingPlayer.board.printPrivateBoard();\n        let spaceType = Object.keys(attackLanded)[0]; \n        if (spaceType === 'ship') {\n            winner = receivingPlayer.board.allShipsSunk() \n                ? attackingPlayer : undefined;\n            continue;\n        }\n        attackingPlayer = attackingPlayer === player1 ? player2 : player1;\n        receivingPlayer = receivingPlayer === player1 ? player2 : player1; \n    }\n    while (!winner)\n    return winner;\n}","import { Gameboard, Player, gameplay } from \"./gameObjects\"; \n\nfunction buildElement(tag, id = '', innerHTML = '') {\n    const element = document.createElement(tag);\n    element.id = id;\n    element.innerHTML = innerHTML;\n    return element\n}\n\nexport function buildNewGameButton() {\n    const button = buildElement(\n        'button', 'starter', 'Start a new game');\n    button.addEventListener('click', renderGameBoards());\n    document.body.append(button)\n    return;\n\n}\n\nfunction renderGameBoards() {\n    const player = Player(true);\n    const comp = Player(false);\n\n    const playerBoard = player.updatePublicBoard();\n    const playerTable = buildElement('table','player');\n    const compBoard = comp.updatePublicBoard();\n    const compTable = buildElement('table','comp');\n\n    for (let i = 0; i < playerBoard.length; i++) {\n        const playerRow = buildElement('tr', `row(${i})`);\n        const compRow = buildElement('tr', `row(${i})`);\n        playerTable.append(playerRow);\n        compTable.append(compRow);\n        \n        for (let j = 0; j < playerBoard[i].length; j++) {\n            const cellID = `cell(${i},${j})`;\n            const playerCell = buildElement('td', cellID, playerBoard[i][j]);\n            const compCell = buildElement('td', cellID, compBoard[i][j]);\n            playerRow.append(playerCell);\n            compBoard.append(compCell);\n        }\n    }\n\n    document.body.append(playerBoard);\n    document.body.append(compBoard);\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { buildNewGameButton } from './gameUI';\n\nbuildNewGameButton();"],"names":[],"sourceRoot":""}